"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterSearch = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const react_1 = require("react");
const useComposedCssClasses_1 = require("../hooks/useComposedCssClasses");
const useSynchronizedRequest_1 = require("../hooks/useSynchronizedRequest");
const utils_1 = require("../utils");
const filterutils_1 = require("../utils/filterutils");
const Dropdown_1 = require("./Dropdown/Dropdown");
const DropdownInput_1 = require("./Dropdown/DropdownInput");
const DropdownItem_1 = require("./Dropdown/DropdownItem");
const DropdownMenu_1 = require("./Dropdown/DropdownMenu");
const processTranslation_1 = require("./utils/processTranslation");
const renderAutocompleteResult_1 = require("./utils/renderAutocompleteResult");
const builtInCssClasses = {
    filterSearchContainer: 'relative mb-2',
    label: 'mb-4 text-sm font-medium text-neutral-dark',
    inputElement: 'text-sm bg-white outline-none h-9 w-full p-2 rounded-md border border-gray-300 focus:border-primary text-neutral-dark placeholder:text-neutral',
    sectionLabel: 'text-sm text-neutral-dark font-semibold py-2 px-4',
    focusedOption: 'bg-gray-100',
    option: 'text-sm text-neutral-dark py-1 cursor-pointer hover:bg-gray-100 px-4'
};
/**
 * A component which allows a user to search for filters associated with specific entities and fields.
 *
 * @public
 *
 * @param props - {@link FilterSearchProps}
 * @returns A react component for Filter Search
 */
function FilterSearch({ searchFields, label, placeholder = 'Search here...', searchOnSelect, sectioned = false, customCssClasses }) {
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const searchParamFields = searchFields.map((searchField) => {
        return Object.assign(Object.assign({}, searchField), { fetchEntities: false });
    });
    const cssClasses = (0, useComposedCssClasses_1.useComposedCssClasses)(builtInCssClasses, customCssClasses);
    const [currentFilter, setCurrentFilter] = (0, react_1.useState)();
    const [filterQuery, setFilterQuery] = (0, react_1.useState)();
    const staticFilters = (0, search_headless_react_1.useSearchState)(state => state.filters.static);
    const fieldValueFilters = (0, react_1.useMemo)(() => (0, filterutils_1.getSelectableFieldValueFilters)(staticFilters !== null && staticFilters !== void 0 ? staticFilters : []), [staticFilters]);
    const [filterSearchResponse, executeFilterSearch, clearFilterSearchResponse] = (0, useSynchronizedRequest_1.useSynchronizedRequest)(inputValue => {
        setFilterQuery(inputValue);
        return searchActions.executeFilterSearch(inputValue !== null && inputValue !== void 0 ? inputValue : '', sectioned, searchParamFields);
    }, (e) => console.error('Error occured executing a filter search request.\n', e));
    (0, react_1.useEffect)(() => {
        if (currentFilter && (fieldValueFilters === null || fieldValueFilters === void 0 ? void 0 : fieldValueFilters.find(f => (0, filterutils_1.isDuplicateFieldValueFilter)(f, currentFilter) && !f.selected))) {
            clearFilterSearchResponse();
            setCurrentFilter(undefined);
            setFilterQuery('');
        }
    }, [clearFilterSearchResponse, currentFilter, fieldValueFilters]);
    const sections = (0, react_1.useMemo)(() => {
        var _a;
        return (_a = filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections.filter(section => section.results.length > 0)) !== null && _a !== void 0 ? _a : [];
    }, [filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections]);
    const hasResults = sections.flatMap(s => s.results).length > 0;
    const handleDropdownEvent = (0, react_1.useCallback)((value, itemData, select) => {
        const newFilter = itemData === null || itemData === void 0 ? void 0 : itemData.filter;
        const newDisplayName = itemData === null || itemData === void 0 ? void 0 : itemData.displayName;
        if (newFilter && newDisplayName) {
            if (select) {
                if (currentFilter) {
                    searchActions.setFilterOption({ filter: currentFilter, selected: false });
                }
                searchActions.setFilterOption({ filter: newFilter, displayName: newDisplayName, selected: true
                });
                setCurrentFilter(newFilter);
                setFilterQuery(newDisplayName);
                executeFilterSearch(newDisplayName);
                if (searchOnSelect) {
                    searchActions.setOffset(0);
                    searchActions.resetFacets();
                    (0, utils_1.executeSearch)(searchActions);
                }
            }
            else {
                setFilterQuery(value);
                executeFilterSearch(value);
            }
        }
    }, [currentFilter, searchActions, executeFilterSearch, searchOnSelect]);
    const handleSelectDropdown = (0, react_1.useCallback)((value, _index, itemData) => {
        handleDropdownEvent(value, itemData, true);
    }, [handleDropdownEvent]);
    const handleToggleDropdown = (0, react_1.useCallback)((isActive, _prevValue, value, _index, itemData) => {
        if (!isActive) {
            handleDropdownEvent(value, itemData, false);
        }
    }, [handleDropdownEvent]);
    const meetsSubmitCritera = (0, react_1.useCallback)(index => index >= 0, []);
    const itemDataMatrix = (0, react_1.useMemo)(() => {
        return sections.map(section => {
            return section.results.map(result => ({
                filter: Object.assign(Object.assign({}, result.filter), { kind: 'fieldValue' }),
                displayName: result.value
            }));
        });
    }, [sections]);
    function renderDropdownItems() {
        return sections.map((section, sectionIndex) => {
            return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'pb-2' }, { children: [section.label &&
                        (0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.sectionLabel }, { children: section.label }), void 0), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.optionsContainer }, { children: section.results.map((result, index) => ((0, jsx_runtime_1.jsx)(DropdownItem_1.DropdownItem, Object.assign({ focusedClassName: cssClasses.focusedOption, value: result.value, itemData: itemDataMatrix[sectionIndex][index] }, { children: (0, renderAutocompleteResult_1.renderAutocompleteResult)(result, cssClasses) }), index))) }), void 0)] }), sectionIndex));
        });
    }
    const handleInputFocus = (0, react_1.useCallback)((value = '') => {
        if (value) {
            executeFilterSearch(value);
        }
    }, [executeFilterSearch]);
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: cssClasses.filterSearchContainer }, { children: [label && (0, jsx_runtime_1.jsx)("h1", Object.assign({ className: cssClasses.label }, { children: label }), void 0), (0, jsx_runtime_1.jsxs)(Dropdown_1.Dropdown, Object.assign({ screenReaderText: getScreenReaderText(sections), onSelect: handleSelectDropdown, onToggle: handleToggleDropdown, alwaysSelectOption: true, parentQuery: filterQuery }, { children: [(0, jsx_runtime_1.jsx)(DropdownInput_1.DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onChange: executeFilterSearch, onFocus: handleInputFocus, submitCriteria: meetsSubmitCritera }, void 0), (0, jsx_runtime_1.jsx)(DropdownMenu_1.DropdownMenu, { children: hasResults &&
                            (0, jsx_runtime_1.jsx)("div", Object.assign({ className: 'absolute z-10 w-full shadow-lg rounded-md border border-gray-300 bg-white pt-3 pb-1 mt-1' }, { children: renderDropdownItems() }), void 0) }, void 0)] }), void 0)] }), void 0));
}
exports.FilterSearch = FilterSearch;
function getScreenReaderText(sections) {
    let screenReaderText = (0, processTranslation_1.processTranslation)({
        phrase: '0 autocomplete option found.',
        pluralForm: '0 autocomplete options found.',
        count: 0
    });
    if (sections.length === 0) {
        return screenReaderText;
    }
    const screenReaderPhrases = sections.map(section => {
        const optionInfo = section.label
            ? `${section.results.length} ${section.label}`
            : `${section.results.length}`;
        return (0, processTranslation_1.processTranslation)({
            phrase: `${optionInfo} autocomplete option found.`,
            pluralForm: `${optionInfo} autocomplete options found.`,
            count: section.results.length
        });
    });
    screenReaderText = screenReaderPhrases.join(' ');
    return screenReaderText;
}
//# sourceMappingURL=FilterSearch.js.map