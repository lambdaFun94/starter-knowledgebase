import { makeNumber, randomize, flattenObj, getDOMNodeAddress } from "./utils";
import ReactDOM from "react-dom";
import React from "react";
import UsagePanel from "./UsagePanel";
import s from "./UsageTooltip.module.css";
function enableWatchDOMForChanges(rerender, watchElement, rssProps) {
  const observerConfig = { attributes: true, childList: true, subtree: true };
  const observer = new MutationObserver((mutationsList, observer2) => {
    mutationsList.forEach((mutation) => {
      if (mutation.attributeName && mutation.attributeName.includes("cfd")) {
        return;
      }
      if (mutation.addedNodes.length < 1) {
        return;
      }
      observer2.disconnect();
      disableAndCleanupCFDebugger();
      const [fakeProps, flatProps] = generateRandomizedProps(rssProps);
      rerender(fakeProps);
      const usageList = findFieldValueUsages(flatProps, document.body);
      rerender(rssProps);
      addDataAttributeTags(usageList, document.body);
      enableTooltipVisualization();
      enableUsageVisualization(rssProps);
      observer2.observe(watchElement, observerConfig);
    });
  });
  observer.observe(watchElement, observerConfig);
}
function disableAndCleanupCFDebugger() {
  document.querySelectorAll("[data-cfd-tooltip]").forEach((el) => {
    if (!(el instanceof HTMLElement)) {
      return;
    }
    Object.entries(el.dataset).forEach(([key, _]) => {
      if (key.includes("cfdSource") || key.includes("cfdUsageType") || key.includes("cfdTooltip")) {
        delete el.dataset[key];
      }
    });
  });
  document.querySelectorAll(".CFD-tooltip").forEach((el) => el.remove());
  document.querySelectorAll(".CFD-usagePanel").forEach((el) => el.remove());
}
function generateRandomizedProps(rssProps) {
  const randomizedProps = randomize(rssProps);
  return [randomizedProps, flattenObj(randomizedProps)];
}
function findFieldValueUsages(fieldValues, sourceDOM) {
  const usageList = [];
  Object.entries(fieldValues).forEach(([key, fieldValue]) => {
    const nodeIterator = document.createNodeIterator(
      sourceDOM,
      NodeFilter.SHOW_ALL,
      (node) => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.includes(fieldValue)) {
          node.cfdUsage = "Text Content";
          return NodeFilter.FILTER_ACCEPT;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          if (!(node instanceof HTMLElement)) {
            return NodeFilter.FILTER_REJECT;
          }
          const attrs = node.getAttributeNames();
          for (const attrName of attrs) {
            if (node.getAttribute(attrName) === fieldValue) {
              node.cfdUsage = `Attribute: ${attrName}`;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }
        return NodeFilter.FILTER_REJECT;
      }
    );
    let nodeWithData;
    while (nodeWithData = nodeIterator.nextNode()) {
      let addressSelector = getDOMNodeAddress(nodeWithData);
      usageList.push({
        selector: addressSelector,
        key,
        usageType: nodeWithData.cfdUsage
      });
    }
  });
  return usageList;
}
function addDataAttributeTags(usageList, targetDOM) {
  usageList.forEach((usageInfo) => {
    if (!usageInfo.selector) {
      return;
    }
    let el = targetDOM.querySelector(usageInfo.selector);
    if (!(el instanceof HTMLElement)) {
      return;
    }
    el.dataset.cfdTooltip = "true";
    const randKey = makeNumber(12);
    el.dataset[`cfdSource_${randKey}`] = usageInfo.key;
    el.dataset[`cfdUsageType_${randKey}`] = usageInfo.usageType;
  });
}
function initCFDebugger(renderFunction, rssProps) {
  const [fakeProps, flatFakeProps] = generateRandomizedProps(rssProps);
  const VDOM = document.cloneNode(true);
  const vRoot = VDOM.querySelector("#root");
  if (!(vRoot instanceof HTMLElement)) {
    return;
  }
  renderFunction(fakeProps, vRoot);
  const usageList = findFieldValueUsages(flatFakeProps, VDOM.body);
  addDataAttributeTags(usageList, document.body);
  enableTooltipVisualization();
  enableUsageVisualization(rssProps);
  const documentRoot = document.querySelector("#root");
  if (documentRoot) {
    enableWatchDOMForChanges(renderFunction, documentRoot, rssProps);
  }
}
function enableTooltipVisualization() {
  document.querySelectorAll("[data-cfd-tooltip]").forEach((el) => {
    if (!(el instanceof HTMLElement)) {
      return;
    }
    let cfdInfo = {};
    Object.entries(el.dataset).forEach(([key, val]) => {
      if (key.includes("cfdSource")) {
        const [_, id] = key.split("_");
        if (!cfdInfo[id]) {
          cfdInfo[id] = {};
        }
        cfdInfo[id].source = el.dataset[key];
      } else if (key.includes("cfdUsageType")) {
        const [_, id] = key.split("_");
        if (!cfdInfo[id]) {
          cfdInfo[id] = {};
        }
        cfdInfo[id].usage = el.dataset[key];
      }
    });
    const toolTipEl = document.createElement("div");
    toolTipEl.classList.add(s.tooltip);
    let innerHTML = "";
    Object.entries(cfdInfo).forEach(([key, val]) => {
      let shortSource = val.source;
      const prefix = "document.";
      if (shortSource?.startsWith(prefix)) {
        shortSource = shortSource.slice(prefix.length);
      }
      innerHTML = innerHTML + `<div class="${s.section}">
        <span class="${s.source}">Data Field: ${shortSource}</span>
        <span class="${s.usage}">Usage: ${val.usage}</span>
        </div>`;
    });
    toolTipEl.innerHTML = innerHTML;
    el.addEventListener("mouseenter", () => {
      const elRect = el.getBoundingClientRect();
      toolTipEl.style.top = `${elRect.bottom + window.scrollY}px`;
      toolTipEl.style.left = `${elRect.left}px`;
      document.body.appendChild(toolTipEl);
    });
    el.addEventListener("mouseleave", () => {
      toolTipEl.remove();
    });
  });
}
function enableUsageVisualization(rssProps) {
  const flatProfile = flattenObj(rssProps);
  const cfEls = document.querySelectorAll("[data-cfd-tooltip]");
  const usageMap = {};
  Object.entries(flatProfile).forEach(([profileKey, _]) => {
    cfEls.forEach((el) => {
      if (!(el instanceof HTMLElement)) {
        return;
      }
      Object.entries(el.dataset).forEach(([_2, tooltipVal]) => {
        if (profileKey === tooltipVal) {
          usageMap[profileKey] = [
            ...usageMap[profileKey] ? usageMap[profileKey] : [],
            el
          ];
        }
      });
    });
  });
  let usagePanelContainerEl = document.createElement("div");
  usagePanelContainerEl.id = "usagePanelContainer";
  document.body.appendChild(usagePanelContainerEl);
  ReactDOM.render(
    React.createElement(UsagePanel, {
      fields: flatProfile,
      usageMap,
      proxyUsageList: window.cfdProxyUsage
    }),
    usagePanelContainerEl
  );
}
export {
  initCFDebugger
};
