import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useSearchActions, useSearchState } from '@yext/search-headless-react';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { useComposedCssClasses } from '../hooks/useComposedCssClasses';
import { useSynchronizedRequest } from '../hooks/useSynchronizedRequest';
import { executeSearch } from '../utils';
import { getSelectableFieldValueFilters, isDuplicateFieldValueFilter } from '../utils/filterutils';
import { Dropdown } from './Dropdown/Dropdown';
import { DropdownInput } from './Dropdown/DropdownInput';
import { DropdownItem } from './Dropdown/DropdownItem';
import { DropdownMenu } from './Dropdown/DropdownMenu';
import { processTranslation } from './utils/processTranslation';
import { renderAutocompleteResult } from './utils/renderAutocompleteResult';
const builtInCssClasses = {
    filterSearchContainer: 'relative mb-2',
    label: 'mb-4 text-sm font-medium text-neutral-dark',
    inputElement: 'text-sm bg-white outline-none h-9 w-full p-2 rounded-md border border-gray-300 focus:border-primary text-neutral-dark placeholder:text-neutral',
    sectionLabel: 'text-sm text-neutral-dark font-semibold py-2 px-4',
    focusedOption: 'bg-gray-100',
    option: 'text-sm text-neutral-dark py-1 cursor-pointer hover:bg-gray-100 px-4'
};
/**
 * A component which allows a user to search for filters associated with specific entities and fields.
 *
 * @public
 *
 * @param props - {@link FilterSearchProps}
 * @returns A react component for Filter Search
 */
export function FilterSearch({ searchFields, label, placeholder = 'Search here...', searchOnSelect, sectioned = false, customCssClasses }) {
    const searchActions = useSearchActions();
    const searchParamFields = searchFields.map((searchField) => {
        return Object.assign(Object.assign({}, searchField), { fetchEntities: false });
    });
    const cssClasses = useComposedCssClasses(builtInCssClasses, customCssClasses);
    const [currentFilter, setCurrentFilter] = useState();
    const [filterQuery, setFilterQuery] = useState();
    const staticFilters = useSearchState(state => state.filters.static);
    const fieldValueFilters = useMemo(() => getSelectableFieldValueFilters(staticFilters !== null && staticFilters !== void 0 ? staticFilters : []), [staticFilters]);
    const [filterSearchResponse, executeFilterSearch, clearFilterSearchResponse] = useSynchronizedRequest(inputValue => {
        setFilterQuery(inputValue);
        return searchActions.executeFilterSearch(inputValue !== null && inputValue !== void 0 ? inputValue : '', sectioned, searchParamFields);
    }, (e) => console.error('Error occured executing a filter search request.\n', e));
    useEffect(() => {
        if (currentFilter && (fieldValueFilters === null || fieldValueFilters === void 0 ? void 0 : fieldValueFilters.find(f => isDuplicateFieldValueFilter(f, currentFilter) && !f.selected))) {
            clearFilterSearchResponse();
            setCurrentFilter(undefined);
            setFilterQuery('');
        }
    }, [clearFilterSearchResponse, currentFilter, fieldValueFilters]);
    const sections = useMemo(() => {
        var _a;
        return (_a = filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections.filter(section => section.results.length > 0)) !== null && _a !== void 0 ? _a : [];
    }, [filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections]);
    const hasResults = sections.flatMap(s => s.results).length > 0;
    const handleDropdownEvent = useCallback((value, itemData, select) => {
        const newFilter = itemData === null || itemData === void 0 ? void 0 : itemData.filter;
        const newDisplayName = itemData === null || itemData === void 0 ? void 0 : itemData.displayName;
        if (newFilter && newDisplayName) {
            if (select) {
                if (currentFilter) {
                    searchActions.setFilterOption({ filter: currentFilter, selected: false });
                }
                searchActions.setFilterOption({ filter: newFilter, displayName: newDisplayName, selected: true
                });
                setCurrentFilter(newFilter);
                setFilterQuery(newDisplayName);
                executeFilterSearch(newDisplayName);
                if (searchOnSelect) {
                    searchActions.setOffset(0);
                    searchActions.resetFacets();
                    executeSearch(searchActions);
                }
            }
            else {
                setFilterQuery(value);
                executeFilterSearch(value);
            }
        }
    }, [currentFilter, searchActions, executeFilterSearch, searchOnSelect]);
    const handleSelectDropdown = useCallback((value, _index, itemData) => {
        handleDropdownEvent(value, itemData, true);
    }, [handleDropdownEvent]);
    const handleToggleDropdown = useCallback((isActive, _prevValue, value, _index, itemData) => {
        if (!isActive) {
            handleDropdownEvent(value, itemData, false);
        }
    }, [handleDropdownEvent]);
    const meetsSubmitCritera = useCallback(index => index >= 0, []);
    const itemDataMatrix = useMemo(() => {
        return sections.map(section => {
            return section.results.map(result => ({
                filter: Object.assign(Object.assign({}, result.filter), { kind: 'fieldValue' }),
                displayName: result.value
            }));
        });
    }, [sections]);
    function renderDropdownItems() {
        return sections.map((section, sectionIndex) => {
            return (_jsxs("div", Object.assign({ className: 'pb-2' }, { children: [section.label &&
                        _jsx("div", Object.assign({ className: cssClasses.sectionLabel }, { children: section.label }), void 0), _jsx("div", Object.assign({ className: cssClasses.optionsContainer }, { children: section.results.map((result, index) => (_jsx(DropdownItem, Object.assign({ focusedClassName: cssClasses.focusedOption, value: result.value, itemData: itemDataMatrix[sectionIndex][index] }, { children: renderAutocompleteResult(result, cssClasses) }), index))) }), void 0)] }), sectionIndex));
        });
    }
    const handleInputFocus = useCallback((value = '') => {
        if (value) {
            executeFilterSearch(value);
        }
    }, [executeFilterSearch]);
    return (_jsxs("div", Object.assign({ className: cssClasses.filterSearchContainer }, { children: [label && _jsx("h1", Object.assign({ className: cssClasses.label }, { children: label }), void 0), _jsxs(Dropdown, Object.assign({ screenReaderText: getScreenReaderText(sections), onSelect: handleSelectDropdown, onToggle: handleToggleDropdown, alwaysSelectOption: true, parentQuery: filterQuery }, { children: [_jsx(DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onChange: executeFilterSearch, onFocus: handleInputFocus, submitCriteria: meetsSubmitCritera }, void 0), _jsx(DropdownMenu, { children: hasResults &&
                            _jsx("div", Object.assign({ className: 'absolute z-10 w-full shadow-lg rounded-md border border-gray-300 bg-white pt-3 pb-1 mt-1' }, { children: renderDropdownItems() }), void 0) }, void 0)] }), void 0)] }), void 0));
}
function getScreenReaderText(sections) {
    let screenReaderText = processTranslation({
        phrase: '0 autocomplete option found.',
        pluralForm: '0 autocomplete options found.',
        count: 0
    });
    if (sections.length === 0) {
        return screenReaderText;
    }
    const screenReaderPhrases = sections.map(section => {
        const optionInfo = section.label
            ? `${section.results.length} ${section.label}`
            : `${section.results.length}`;
        return processTranslation({
            phrase: `${optionInfo} autocomplete option found.`,
            pluralForm: `${optionInfo} autocomplete options found.`,
            count: section.results.length
        });
    });
    screenReaderText = screenReaderPhrases.join(' ');
    return screenReaderText;
}
//# sourceMappingURL=FilterSearch.js.map